#####################################################################################
#
# Trait Dependent Protracted Speciation Model TraDeRProS with RevBayes
#
# This script sets up the model. 
# 
# authors: Guilherme Azevedo
# Please see and cite Azevedo et al. 2024
#
#####################################################################################

# Create helpers variables vor the moves and monitors.
moves = VectorMoves()
monitors = VectorMonitors()

# Seed number
if (seed_number!=0){
  seed(seed_number)
  }

# Read the tree file
tree <- readTrees(treePath)[1]

# Save tree with branch indexes
writeNexus(tree, filename=outDirPath+outputPrefix+"_indexed.tree.nex")

# Get the number of nodes and branches
n_nodes <- tree.nnodes()
n_branches <- n_nodes -1

# Read population to species map
popMap = readDataDelimitedFile(popMapPath, header=TRUE)

# Read trait data
trait <- readDiscreteCharacterData(traitPath)

# Get number of states
n_states <- trait.getStateDescriptions().size()

## Global trait transition
## We are commenting this out because we are using a fixed rate defined in the set up file
#global_trans_rate ~  dnExp(traRate_expoDistrib_parameter)
#moves.append( mvScale( global_trans_rate, weight=1 ) )
#
## Relative Transition with reversible jumps
#n_rates = n_states * (n_states-1)
#relative_transition ~ dnReversibleJumpMixture( simplex(1,0), dnDirichlet(rep(1, n_states)), p=0.5 )
#
#moves.append( mvRJSwitch(relative_transition , weight=1.0) )
#moves.append( mvDirichletSimplex( relative_transition, weight=1 ) )
#
#is_troglo_reversible := ifelse( relative_transition == simplex(1,0), 0.0, 1.0)

# Q matrix
Q := fnFreeK(relative_transition, rescale=TRUE)

# Root prior
rf <- simplex(rep(1,n_states))

# If you do not want to assume equal probabilities:
#rf_prior <- rep(1, n_states)
#rf ~ dnDirichlet( rf_prior )
#moves.append( mvDirichletSimplex( rf, weight=1 ) )

# The Data Augmented PhyloCTMC
trait_evol ~ dnPhyloCTMCDASiteIID(tree,
                                  Q,
                                  branchRates=global_trans_rate,
                                  type="Standard",
                                  nSites=1,
                                  rootFrequencies=rf)

trait_evol.clamp(trait)

moves.append( mvCharacterHistory(ctmc=trait_evol, 
                                 qmap_site=Q,
                                 graph="node",
                                 proposal="rejection",
                                 weight=round(n_nodes/2)) )
moves.append( mvCharacterHistory(ctmc=trait_evol,
                                 qmap_site=Q,
                                 graph="branch",
                                 proposal="rejection",
                                 weight=round(n_branches/2)) )


# Global Speciation completion rate
expected_rate := ln(abs(totalSpecies-1))/tree.rootAge()
sd_real <- exp(lognormal_sd)
mean := ln(abs(expected_rate)) + ln(sd_real)^2
SpeciationComplRate ~ dnLognormal(abs(mean), lognormal_sd)
SpeciationComplRate.setValue(expected_rate)

moves.append(mvScale(SpeciationComplRate, weight=1))

# State specific speciation completion rate with reversible jumps
stateSpecificRateWeights ~ dnReversibleJumpMixture( simplex(rep(1, n_states)), dnDirichlet(rep(1, n_states)), p=0.5 )

moves.append( mvRJSwitch(stateSpecificRateWeights, weight=1.0) )
moves.append(mvSimplex(stateSpecificRateWeights, weight=1))

is_spCompletion_state_dependent := ifelse( stateSpecificRateWeights == simplex(rep(1, n_states)), 0.0, 1.0)

stateSpecificRates := stateSpecificRateWeights * SpeciationComplRate

# State specific branch rates
for(i in 1:n_branches) {
    state_branch_rate[i] := sum(trait_evol.relativeTimeInStates(i,1) * stateSpecificRates)
}

# The Trait Dependent Rates Protracted Speciation Tree
TreeSpeciesTip <- tree
for (i in 1:popMap.size()){
    TreeSpeciesTip.setTaxonName(popMap[i][1], popMap[i][2] )
    }
write(TreeSpeciesTip, filename=outDirPath+outputPrefix+".SpeciesName.tree" )

# Stochastic speciation events on branches
for (i in 1:(n_branches)){
    branch_speciation_events[i] ~ dnPoisson(exp(state_branch_rate[i]*TreeSpeciesTip.branchLength(i)))
}

# Iterate to clamp observed non-speciatipn completion events
iteration=1
for (i in (tree.ntips()+1):n_nodes){
    j=iteration++
    # Visit every internal node i of the tree and get child branches indices and branch lengths
    c1[j] = TreeSpeciesTip.child(i,1)
    c2[j]  = TreeSpeciesTip.child(i,2)

    # Get the descendants of each child to know if they connect same or different species
    c1descendants[j] = TreeSpeciesTip.getDescendantTaxa(c1[j])
    c2descendants[j] = TreeSpeciesTip.getDescendantTaxa(c2[j])

    # Get a list of descendant species to know if node connects population of same or different species
    c1splist[j] = [c1descendants[j][1].getName()]
    if (c1descendants[j].size() > 1){
        for (n in 2:c1descendants[j].size()){
        c1splist[j].append([c1descendants[j][n].getName()])
        }
    }
    c1splist[j].unique()

    c2splist[j] = [c2descendants[j][1].getName()]
    if (c2descendants[j].size() > 1){
        for (n in 2:c2descendants[j].size()){
        c2splist[j].append([c2descendants[j][n].getName()])
        }
    }
    c2splist[j].unique()

    # If node connects populations of same species, clamp the observed value to 0 to indicate that no speciation can be observed. It is only applicable if the species has known assignments. If node connects population of different species we assign moves to it so it can be sampled during MCMC.
    if ((c1splist[j].size() == 1 & c2splist[j].size() == 1 & c1splist[j].contains("unknown")==FALSE & c2splist[j].contains("unknown")==FALSE) & ( c1splist[j][1] == c2splist[j][1])) {
        branch_speciation_events[c1[j]].clamp(0)
        branch_speciation_events[c2[j]].clamp(0)
    } else {
        moves.append(mvRandomNaturalWalk(branch_speciation_events[c1[j]], weight=1))
        moves.append(mvRandomNaturalWalk(branch_speciation_events[c2[j]], weight=1))
    }
}

# Reversible jump to track probability of speciation in target branches
branch_speciation_events[115] ~ dnReversibleJumpMixture( 0, dnPoisson(exp(state_branch_rate[115]*TreeSpeciesTip.branchLength(115))), p=0.5 )
moves.append( mvRJSwitch(branch_speciation_events[115], weight=1.0) )
speciation_br115 := ifelse(branch_speciation_events[115] == 0, 0, 1)

branch_speciation_events[116] ~ dnReversibleJumpMixture( 0, dnPoisson(exp(state_branch_rate[116]*TreeSpeciesTip.branchLength(116))), p=0.5 )
moves.append( mvRJSwitch(branch_speciation_events[116], weight=1.0) )
speciation_br116 := ifelse(branch_speciation_events[116] == 0, 0, 1)

branch_speciation_events[117] ~ dnReversibleJumpMixture( 0, dnPoisson(exp(state_branch_rate[117]*TreeSpeciesTip.branchLength(117))), p=0.5 )
moves.append( mvRJSwitch(branch_speciation_events[117], weight=1.0) )
speciation_br117 := ifelse(branch_speciation_events[117] == 0, 0, 1)

branch_speciation_events[118] ~ dnReversibleJumpMixture( 0, dnPoisson(exp(state_branch_rate[118]*TreeSpeciesTip.branchLength(118))), p=0.5 )
moves.append( mvRJSwitch(branch_speciation_events[118], weight=1.0) )
speciation_br118 := ifelse(branch_speciation_events[118] == 0, 0, 1)

branch_speciation_events[119] ~ dnReversibleJumpMixture( 0, dnPoisson(exp(state_branch_rate[119]*TreeSpeciesTip.branchLength(119))), p=0.5 )
moves.append( mvRJSwitch(branch_speciation_events[119], weight=1.0) )
speciation_br119 := ifelse(branch_speciation_events[119] == 0, 0, 1)

branch_speciation_events[127] ~ dnReversibleJumpMixture( 0, dnPoisson(exp(state_branch_rate[127]*TreeSpeciesTip.branchLength(127))), p=0.5 )
moves.append( mvRJSwitch(branch_speciation_events[127], weight=1.0) )
speciation_br127 := ifelse(branch_speciation_events[127] == 0, 0, 1)

branch_speciation_events[128] ~ dnReversibleJumpMixture( 0, dnPoisson(exp(state_branch_rate[128]*TreeSpeciesTip.branchLength(128))), p=0.5 )
moves.append( mvRJSwitch(branch_speciation_events[128], weight=1.0) )
speciation_br128 := ifelse(branch_speciation_events[128] == 0, 0, 1)

branch_speciation_events[129] ~ dnReversibleJumpMixture( 0, dnPoisson(exp(state_branch_rate[129]*TreeSpeciesTip.branchLength(129))), p=0.5 )
moves.append( mvRJSwitch(branch_speciation_events[129], weight=1.0) )
speciation_br129 := ifelse(branch_speciation_events[129] == 0, 0, 1)

branch_speciation_events[140] ~ dnReversibleJumpMixture( 0, dnPoisson(exp(state_branch_rate[140]*TreeSpeciesTip.branchLength(140))), p=0.5 )
moves.append( mvRJSwitch(branch_speciation_events[140], weight=1.0) )
speciation_br140 := ifelse(branch_speciation_events[140] == 0, 0, 1)

branch_speciation_events[141] ~ dnReversibleJumpMixture( 0, dnPoisson(exp(state_branch_rate[141]*TreeSpeciesTip.branchLength(141))), p=0.5 )
moves.append( mvRJSwitch(branch_speciation_events[141], weight=1.0) )
speciation_br141 := ifelse(branch_speciation_events[141] == 0, 0, 1)

branch_speciation_events[142] ~ dnReversibleJumpMixture( 0, dnPoisson(exp(state_branch_rate[142]*TreeSpeciesTip.branchLength(142))), p=0.5 )
moves.append( mvRJSwitch(branch_speciation_events[142], weight=1.0) )
speciation_br142 := ifelse(branch_speciation_events[142] == 0, 0, 1)

# The tree with speciation events as branch lengths
topology <- readBranchLengthTrees(outDirPath+outputPrefix+".SpeciesName.tree")[1]
SpeciationBranchTree := fnTreeAssembly(topology, branch_speciation_events)

topologyPopNames <- readBranchLengthTrees(treePath)[1]
SpeciationBranchTreePoNames := fnTreeAssembly(topologyPopNames, branch_speciation_events)

# The likelihood function to constraint search to events compatible with the observed species limits

print("Creating speciation distance matrix...")

distanceMatrix := fnTreePairwiseDistances(SpeciationBranchTree)

index=1
maxSpeciationConnectingTwoTips = totalSpecies-1
for (i in 1:distanceMatrix.size()){
    for (j in 1:distanceMatrix.size()){
      if ((distanceMatrix.names()[i] != distanceMatrix.names()[j]) & (distanceMatrix.names()[i]!= "unknown" & distanceMatrix.names()[j]!= "unknown")){
        m=index++
        constraintViolation[m] ~ dnUniformInteger(int(distanceMatrix.matrix()[i][j]- maxSpeciationConnectingTwoTips),
                                                    int(distanceMatrix.matrix()[i][j]- 1))
        constraintViolation[m].clamp(0) 
      }
    }
}

# Constraint for the minimum number of speciation in the whole tree
min_n_species = 70
max_n_species = 100
n_speciation_events := sum(branch_speciation_events)
deviation_of_expected_events ~ dnUniformInteger(n_speciation_events - (max_n_species-1),
                                   n_speciation_events - (min_n_species-1)
                                   )
deviation_of_expected_events.clamp(0)

# Finalize the model
mymodel = model(branch_speciation_events)